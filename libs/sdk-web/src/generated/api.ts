/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Ceerion Email Platform API
 * Email platform API for mail.ceerion.com
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddTrustedSender201,
  AddTrustedSenderBody,
  Error,
  GetDmarcSummary200,
  GetDmarcSummaryBody,
  GetMessageBody,
  ListMessages200,
  ListMessagesBody,
  ListTrustedSenders200,
  ListTrustedSendersParams,
  Login200,
  LoginBody,
  Message,
  RefreshToken200,
  RefreshTokenBody,
  SendMessage200,
  SendRequest,
  User
} from './models';

import { customInstance } from '../http-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Authenticate user
 */
export const login = (
    loginBody: LoginBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Login200>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginBody, signal
    },
      options);
    }
  


export const getLoginMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginBody}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginBody
    export type LoginMutationError = Error

    /**
 * @summary Authenticate user
 */
export const useLogin = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: LoginBody},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Refresh access token
 */
export const refreshToken = (
    refreshTokenBody: RefreshTokenBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RefreshToken200>(
      {url: `/auth/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshTokenBody, signal
    },
      options);
    }
  


export const getRefreshTokenMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: RefreshTokenBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: RefreshTokenBody}, TContext> => {

const mutationKey = ['refreshToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, {data: RefreshTokenBody}> = (props) => {
          const {data} = props ?? {};

          return  refreshToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>
    export type RefreshTokenMutationBody = RefreshTokenBody
    export type RefreshTokenMutationError = Error

    /**
 * @summary Refresh access token
 */
export const useRefreshToken = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,{data: RefreshTokenBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshToken>>,
        TError,
        {data: RefreshTokenBody},
        TContext
      > => {

      const mutationOptions = getRefreshTokenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get current user profile
 */
export const getCurrentUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<User>(
      {url: `/users/me`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentUserQueryKey = () => {
    return [`/users/me`] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = Error>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = Error


export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = Error>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Get current user profile
 */

export function useGetCurrentUser<TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = Error>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List email messages
 */
export const listMessages = (
    listMessagesBody: ListMessagesBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListMessages200>(
      {url: `/mail/messages:list`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: listMessagesBody, signal
    },
      options);
    }
  


export const getListMessagesMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof listMessages>>, TError,{data: ListMessagesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof listMessages>>, TError,{data: ListMessagesBody}, TContext> => {

const mutationKey = ['listMessages'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof listMessages>>, {data: ListMessagesBody}> = (props) => {
          const {data} = props ?? {};

          return  listMessages(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ListMessagesMutationResult = NonNullable<Awaited<ReturnType<typeof listMessages>>>
    export type ListMessagesMutationBody = ListMessagesBody
    export type ListMessagesMutationError = unknown

    /**
 * @summary List email messages
 */
export const useListMessages = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof listMessages>>, TError,{data: ListMessagesBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof listMessages>>,
        TError,
        {data: ListMessagesBody},
        TContext
      > => {

      const mutationOptions = getListMessagesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get email message
 */
export const getMessage = (
    getMessageBody: GetMessageBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Message>(
      {url: `/mail/messages:get`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: getMessageBody, signal
    },
      options);
    }
  


export const getGetMessageMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMessage>>, TError,{data: GetMessageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getMessage>>, TError,{data: GetMessageBody}, TContext> => {

const mutationKey = ['getMessage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMessage>>, {data: GetMessageBody}> = (props) => {
          const {data} = props ?? {};

          return  getMessage(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetMessageMutationResult = NonNullable<Awaited<ReturnType<typeof getMessage>>>
    export type GetMessageMutationBody = GetMessageBody
    export type GetMessageMutationError = Error

    /**
 * @summary Get email message
 */
export const useGetMessage = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMessage>>, TError,{data: GetMessageBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getMessage>>,
        TError,
        {data: GetMessageBody},
        TContext
      > => {

      const mutationOptions = getGetMessageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Send email message
 */
export const sendMessage = (
    sendRequest: SendRequest,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SendMessage200>(
      {url: `/mail/send`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendRequest, signal
    },
      options);
    }
  


export const getSendMessageMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendMessage>>, TError,{data: SendRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sendMessage>>, TError,{data: SendRequest}, TContext> => {

const mutationKey = ['sendMessage'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendMessage>>, {data: SendRequest}> = (props) => {
          const {data} = props ?? {};

          return  sendMessage(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendMessageMutationResult = NonNullable<Awaited<ReturnType<typeof sendMessage>>>
    export type SendMessageMutationBody = SendRequest
    export type SendMessageMutationError = Error

    /**
 * @summary Send email message
 */
export const useSendMessage = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendMessage>>, TError,{data: SendRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendMessage>>,
        TError,
        {data: SendRequest},
        TContext
      > => {

      const mutationOptions = getSendMessageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get DMARC reports summary
 */
export const getDmarcSummary = (
    getDmarcSummaryBody: GetDmarcSummaryBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetDmarcSummary200>(
      {url: `/deliverability/dmarc-reports:summary`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: getDmarcSummaryBody, signal
    },
      options);
    }
  


export const getGetDmarcSummaryMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getDmarcSummary>>, TError,{data: GetDmarcSummaryBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getDmarcSummary>>, TError,{data: GetDmarcSummaryBody}, TContext> => {

const mutationKey = ['getDmarcSummary'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getDmarcSummary>>, {data: GetDmarcSummaryBody}> = (props) => {
          const {data} = props ?? {};

          return  getDmarcSummary(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetDmarcSummaryMutationResult = NonNullable<Awaited<ReturnType<typeof getDmarcSummary>>>
    export type GetDmarcSummaryMutationBody = GetDmarcSummaryBody
    export type GetDmarcSummaryMutationError = unknown

    /**
 * @summary Get DMARC reports summary
 */
export const useGetDmarcSummary = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getDmarcSummary>>, TError,{data: GetDmarcSummaryBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof getDmarcSummary>>,
        TError,
        {data: GetDmarcSummaryBody},
        TContext
      > => {

      const mutationOptions = getGetDmarcSummaryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary List trusted senders
 */
export const listTrustedSenders = (
    params?: ListTrustedSendersParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<ListTrustedSenders200>(
      {url: `/policy/trusted-senders`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getListTrustedSendersQueryKey = (params?: ListTrustedSendersParams,) => {
    return [`/policy/trusted-senders`, ...(params ? [params]: [])] as const;
    }

    
export const getListTrustedSendersQueryOptions = <TData = Awaited<ReturnType<typeof listTrustedSenders>>, TError = unknown>(params?: ListTrustedSendersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTrustedSenders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTrustedSendersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTrustedSenders>>> = ({ signal }) => listTrustedSenders(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTrustedSenders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListTrustedSendersQueryResult = NonNullable<Awaited<ReturnType<typeof listTrustedSenders>>>
export type ListTrustedSendersQueryError = unknown


export function useListTrustedSenders<TData = Awaited<ReturnType<typeof listTrustedSenders>>, TError = unknown>(
 params: undefined |  ListTrustedSendersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTrustedSenders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTrustedSenders>>,
          TError,
          Awaited<ReturnType<typeof listTrustedSenders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListTrustedSenders<TData = Awaited<ReturnType<typeof listTrustedSenders>>, TError = unknown>(
 params?: ListTrustedSendersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTrustedSenders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTrustedSenders>>,
          TError,
          Awaited<ReturnType<typeof listTrustedSenders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListTrustedSenders<TData = Awaited<ReturnType<typeof listTrustedSenders>>, TError = unknown>(
 params?: ListTrustedSendersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTrustedSenders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary List trusted senders
 */

export function useListTrustedSenders<TData = Awaited<ReturnType<typeof listTrustedSenders>>, TError = unknown>(
 params?: ListTrustedSendersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTrustedSenders>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListTrustedSendersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Add trusted sender
 */
export const addTrustedSender = (
    addTrustedSenderBody: AddTrustedSenderBody,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AddTrustedSender201>(
      {url: `/policy/trusted-senders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addTrustedSenderBody, signal
    },
      options);
    }
  


export const getAddTrustedSenderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTrustedSender>>, TError,{data: AddTrustedSenderBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof addTrustedSender>>, TError,{data: AddTrustedSenderBody}, TContext> => {

const mutationKey = ['addTrustedSender'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addTrustedSender>>, {data: AddTrustedSenderBody}> = (props) => {
          const {data} = props ?? {};

          return  addTrustedSender(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddTrustedSenderMutationResult = NonNullable<Awaited<ReturnType<typeof addTrustedSender>>>
    export type AddTrustedSenderMutationBody = AddTrustedSenderBody
    export type AddTrustedSenderMutationError = unknown

    /**
 * @summary Add trusted sender
 */
export const useAddTrustedSender = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addTrustedSender>>, TError,{data: AddTrustedSenderBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addTrustedSender>>,
        TError,
        {data: AddTrustedSenderBody},
        TContext
      > => {

      const mutationOptions = getAddTrustedSenderMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
